import ast,sys
from collections import namedtuple

generated_template = """
#autogenerated by serial_mock
from itertools import cycle
from serial_mock import serial_query
import serial_mock
import logging
logger = logging.getLogger("serial_mock")

class MySerial(serial_mock.MockSerial):
    prompt = {prompt}
    endline = {endline}
    terminal = {terminal}
    #for simple playback simple queries work well
    simple_queries = {responses}
    
    @serial_query("get -mockver")
    def get_mock_ver(self):
        '''
        just included as a sample to get you going
        '''
        return "RUNNING: %s"%serial_mock.__VERSION__
        


if __name__ == "__main__":
   import sys
   import argparse
   parser = argparse.ArgumentParser()
   parser.add_argument("COM_PORT",help="the com port to bind this class to")
   parser.add_argument("-v","--verbose",help="verbose mode enabled",choices=["ERROR","WARN","DEBUG","INFO"],nargs="?")
   args = parser.parse_args()
   if args.verbose:
      print "SET LOG LEVEL:",args.verbose
      logger.setLevel(getattr(logging,args.verbose,logging.WARN))
   MySerial(args.COM_PORT).MainLoop()
"""
function_template = """
    @serial_query("{query}")
    def {fn_name}(self):
        return next(self.responses["{query}"])
"""
def _parseBridgeFile(fname):
    close = False
    commands_in = []
    commands_out = []
    if isinstance(fname,basestring):
        fname = open(fname,"rb")
        close=True
    try:
        for line in fname:
            if line[0] == "<":
                commands_in.append(ast.literal_eval(line[1:-1]))
            else:
                commands_out.append(ast.literal_eval(line[1:-1]))

        return commands_in,commands_out
    finally:
        if close:
            fname.close()



def pprinttable(rows):
    if len(rows) > 1:
        headers = rows[0]._fields
        lens = []
        for i in range(len(rows[0])):
            lens.append(len(max([x[i] for x in rows] + [headers[i]], key=lambda x: len(str(x)))))
        formats = []
        hformats = []
        for i in range(len(rows[0])):
            if isinstance(rows[0][i], int):
                formats.append("%%%dd" % lens[i])
            else:
                formats.append("%%-%ds" % lens[i])
            hformats.append("%%-%ds" % lens[i])
        pattern = " | ".join(formats)
        hpattern = " | ".join(hformats)
        separator = "-+-".join(['-' * n for n in lens])
        print hpattern % tuple(headers)
        print separator
        _u = lambda t: t.decode('UTF-8', 'replace') if isinstance(t, str) else t
        for line in rows:
            print pattern % tuple(_u(t) for t in line)
    elif len(rows) == 1:
        row = rows[0]
        hwidth = len(max(row._fields, key=lambda x: len(x)))
        for i in range(len(row)):
            print "%*s = %s" % (hwidth, row._fields[i], row[i])

def format_dict(a_dict,spaces=4,indent=2):
    s = ""
    for k,v in a_dict.items():
        if isinstance(v,(list,tuple)) and len(v) == 1:
            v = v[0]
        elif isinstance(v,dict) or hasattr(v,"items"):
            spaces2 = spaces + len(k)
            v = "{\n%s\n"%format_dict(a_dict,spaces2+indent,indent)
            v = " "*spaces+v+" "*spaces+"}"
        s += " "*spaces + repr(k)+": "+repr(v) +",\n"

    return s[:-2]+"\n"
def guess_terminal_and_prompt(input_list):
    terminal,prompt="",""
    for line in input_list:
        if prompt == "":
            prompt = line[-1]
            terminal = line[-2]
        elif prompt is None:
            if terminal != line[-len(terminal):]:
                terminal = None
        else:
            if terminal != line[-2] and prompt == line[-1]:
                terminal = prompt
                prompt = None
    return terminal,prompt

def print_guess(queries,responses):
    QR = namedtuple("qr", ["user_input", "device_response"])
    pprinttable([QR(repr(q),repr(r)) for q,r in zip(queries,responses) ])
    terminal,prompt = guess_terminal_and_prompt(queries)
    print "I think the user terminates commands with %r"%terminal+(prompt if prompt else "")
    terminal1,prompt1 = guess_terminal_and_prompt(responses)
    print "I think the device endslines with %r and gives a data prompt of %r"%(terminal1,prompt1)
    result = "X"
    while result[0].lower() not in "yn":
        result = raw_input("Is This Correct? (y or n)")
    if result[0].lower() == "y":
        return (queries,terminal,prompt),(responses,terminal1,prompt1)
    else:
        result = "X"
        while result[0].lower() not in "yn":
            result = raw_input("Would you like to try and swap the sides? (y or n)")
        if result[0].lower() == "n":
            print "Ok Giving Up"
            raise ValueError("Invalid input file")
        return print_guess(responses,queries)
def convertBridgeFileToInterface(fname,outfile):
    queries,responses= _parseBridgeFile(fname)
    queries,responses= print_guess(queries,responses)
    data = {}
    for k,v in zip(queries[0],responses[0]):
        k = k.strip(queries[1]+(queries[2] if queries[2] else ""))
        v = v.strip(responses[1]+(responses[2] if responses[2] else ""))
        data.setdefault(k,[]).append(v)




    # for i,(key,responses) in enumerate(answer_response.items(),1):
    #     _responses += '"%s":cycle(%s),'%(key,responses)
    #
    #     functions += function_template.format(fn_name="response_handler%d"%i,query=key)
    # _responses += "}"
    terminal = repr(queries[1] + (queries[2] if queries[2] else ""))
    endline,prompt = repr(responses[1]),repr(responses[2] if responses[2] else "")
    data = "{\n"+format_dict(data,6)+" "*4+"}"
    if isinstance(outfile,basestring):
        with open(outfile,"wb") as f:
            f.write(generated_template.format(responses=data,terminal=terminal,prompt=prompt,endline=endline))
    else:
        outfile.write(generated_template.format(responses=data,terminal=terminal,prompt=prompt,endline=endline))

    print "Wrote to ",outfile

